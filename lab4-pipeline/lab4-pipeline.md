## Lab 4: Pipelined Processor

You will need to copy over your ALU code (`lc4_alu.v`, `lc4_cla.v` and `lc4_divider.v`) from previous labs.

Your pipelined LC4 processor must be fully-bypassed, and must predict all branches as not taken (including JMP, TRAP, and RTI). It should stall only in the load-to-use case. To be clear, when you encounter a load-to-use, you insert the NOP bubble as if it was between the load and the use. For example, if you have a `load` followed by an `add`, it would look in the pipeline like you have `load` followed by `NOP` followed by `add` - `load` in W, `NOP` in M, `add` in X.

If there is a **degenerate BR** _B0_ whose target is the next insn (i.e., PC+1), then the not-taken and taken paths are the same for _B0_. However, you should not implement extra logic for this degenerate case. If _B0_ is not taken (based on the NZP registers) then you should not have a flush; if _B0_ is taken, then you should flush. Treat _B0_ just like any other BR, and consider only the taken/not-taken behavior when identifying mispredictions and flushing. Consider also a related degenerate BR _B1_ where the target is PC+2: when we detect the misprediction in Execute the correct target just so happens to be in Fetch, and we could get by with flushing just the Decode insn. Nevertheless, treat all BRs uniformly and flush both Fetch & Decode for _B1_ as well.

At startup, the pipeline should be filled with NOPs and treated as instructions that were flushed due to a branch mispredict (i.e. `test_stall` should be set to 2 - see below). Implement this by setting the default values of your pipeline registers appropriately. See the declaration of `pc_reg` in the single-cycle data path for an example.

To set the initial value of a register, modify the second parameter value.

Note that **reading from a register takes place before writing to it**. You will need to implement a **WD bypass** to avoid stalling when the W insn writes to a register that the D insn reads from in the same cycle.

The initial value of your `pc_reg` in the Fetch stage should be `16'h8200`.

The only time you should stall unnecessarily is on a `BRnzp` instruction that depends on a prior load. (Technically, `BRnzp` doesn't depend on the condition codes of the previous instruction since it will always be taken, but we'll assume any good compiler/programmer will use a `JMP` insn instead so you don't have to handle `BRnzp` specially).

You should bypass at the beginning of a stage to the beginning of another stage, so that values are bypassed right after they come out of your pipeline registers. Some groups have in the past implemented this lab so that they bypass from the end of a stage to the end of another stage, but this is more difficult.

You **should not stall** in situations where you store a piece of data you just loaded, e.g.:
```
LDR R1, R2, 5     // load R1
STR R1, R3, 6     // store R1 -> [R3 + 6]
```
instead, you should forward the load instruction's output from the writeback stage to the store's memory stage. This uses the WM bypass.

Assume that instruction memory is never over-written.

### Test Signals

This lab uses the `test_data/*.ctrace` files, which contain a cycle-by-cycle trace of all of the test signals generated by our solution. Your pipeline should match these signals exactly.

Whereas the test wires should be set in the Writeback stage, `o_cur_pc` is the pc in Fetch stage (the output of the PC register in Fetch stage), and the `o_dmem_*` wires are set in Memory stage.

`test_stall` is a two-bit testbench signal that you should set as follows:
+ 0: no stall
+ 1: reserved for the superscalar design; for this lab, never set test_stall to 1
+ 2: flushed due to misprediction or because the first real instruction hasn't made it through to the writeback stage yet
+ 3: stalled due to load-to-use penalty

All other ports on the processor module are identical to your single-cycle implementation.

`switch_data` and `led_data`: You may safely ignore these ports. They provide your processor with the states of the Zedboard's switches and allow you to control its LEDs. If you want to use these for your own testing, or just for fun, use the example debugging code from the `lc4_single.v` skeleton as a starting point. (Use of the display and LEDs is strictly optional. There are no points or extra credit associated with it.)

### General Advice

Writing sub-modules: It is tempting to make one module for each pipeline stage and/or for each pipeline register. We recommend against this. A single, large module is easier to debug because you can view all the signals in one big list in the debugger. Combinational loops are also somewhat likelier this way, which will cause the simulator to hang (`make synth` will catch such loops, however).

Port/Wire Shadowing: Make sure you do not declare any wires with the same name as a port (equivalent to variable shadowing). By default, the synthesizer will issue a warning about this and ignore the second declaration. One good rule of thumb is to avoid any wire declarations that start with `o_`, `i_`, or `test_`. Reserve these prefixes for the ports.

## Debugging

Debugging this assignment will be **noticeably** harder than debugging the single-cycle datapath. **Get started early and plan on many debug sessions involving all team members!** Also consider the following debugging tips:

+ In the output pane, right-click your PC wires and any others whose values your are monitoring as numbers, and set their radix to hexadecimal.
+ The skeleton `lc4_pipeline.v` contains an `always (posedge gwe)` block at the end. Leave this at the end of the module and add `$display` statements to print out values you are interested in. These will get printed at the end of each cycle, when all wire values are valid. Please **comment out these $display statements** before submitting code to the autograder, as the autograder's email will truncate output (which may then excise relevant errors/warnings).
+ You can set a breakpoint on a `$display` call in your `always` block to get Vivado to break at the end of each cycle. This is much more effective than setting breakpoints elsewhere in your code. An empty `$display();` statement at the very end of the block is especially useful for setting a breakpoint. You can also single-step forward 40ns to move forward one cycle.
+ Start with the `test_alu` test case, and do not move on until it is completely working. Move through the test cases one by one.
+ The testbench can be configured (set `exit_at_first_failure = 1`) to stop as soon as it encounters an error and print out both the line number (n) and instruction.
    + Consider creating a pipeline diagram (as we've used in lecture) of the corresponding ASM file for the first `n` instructions. Mark all bypasses, stalls, squashes, and register contents on your diagram. (Spreadsheets are good for this--use one row for each instruction, one column for each cycle, and fill in the pipeline stages like the examples on the lecture slide.)
    + Next, step through your code by setting a breakpoint in the `always` block, and compare your signals to the expected values in every pipeline stage. This is very helpful to identify undeclared wires (which default to 1 bit wide), incorrect bypass logic, etc.
+ You can print out an instruction's disassembly inside the `@always` block via the `pinstr()` subroutine. See the file `include/lc4_prettyprint_errors.v` for more details.

## Timing closure

You should verify _timing closure_ (i.e., that your processor isn't overclocked) for your design just as [in Lab 3](https://github.com/upenn-acg/cis501/blob/master/lab3-singlecycle/lab3-singlecycle.md#verify-timing-closure). There is no frequency target for you to hit, you can lower the clock as needed to achieve timing closure.

The timing, utilization and power reports for your design are automatically included via `make zip` into the .zip file you submit, so that we can survey the results of the different designs we have all come up with.

## Demo

There is no demo for this lab.
