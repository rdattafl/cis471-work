# Lab 1: Verilog Debugging

This lab will introduce you to the process of building, testing and debugging
Verilog code. For this and the other labs you will work on the [SEAS Biglab
machines](https://www.seas.upenn.edu/cets/answers/biglab.html). The Vivado tools
are too heavyweight to run with the time/memory limitations in place on eniac.

The instructions below **assume that you are running on a biglab machine**.

Note that this is an **individual lab**, so you should complete it on your own.

## Clone github repo

Clone your repo by following [our recommended git setup instructions](https://www.cis.upenn.edu/~cis571/current/git-setup.html).

## Run the tests

We've provided a Verilog testbench with this lab, in the file
`rca_testbench.v`. A testbench is code that generates test inputs, provides each
input to a module being tested (called the UUT/DUT for "unit under test" or
"design under test"), and checks that the output is correct. Testbench code is
purely for simulation, so it can use richer constructs like loops, I/O, etc. that
cannot synthesize into real hardware.

The provided `rca_testbench.v` file tests all possible inputs for each of the
modules in `rca.v` - it is a very thorough testbench, made possible because the
UUTs are quite simple. 

You can run the tests by `cd`-ing into the `lab1` directory (where this file is) 
and running the command `make test`. When you run the tests on the initial 
`rca.v` code, lots of tests will fail.

If you get an error about not being able to find the `iverilog` program, you need to [update your PATH variable](https://opensource.com/article/17/6/set-path-linux) to include the path `/home1/c/cis571/tools/bin/`.

When a test fails, it tells you that something is wrong,
but it doesn't explain why. Careful testing of each module can be helpful in
limiting the amount of code you need to examine: if we had only given tests for
the `rca4` module, and it fails a test, you don't immediately know whether the
bug is in `rca4` itself or in `fulladder2`, `fulladder`, or `halfadder`.

The process of running tests (known as *simulating the design*) may also generate
some warnings. These are important to understand and fix, but in general they
are a small subset of the warnings generated by the synthesis process (see
below).

Instead of investigating the test outputs right now, a more efficient way to
debug can be to see if code analysis tools find any issues with the code. The 
warnings/errors identified this way are usually more specific:
they explain what is wrong and often point to a specific place in the code. This
is a much easier way to find many bugs!

## Run code analysis

Now, from the `lab1` directory, run the command `make check`. This will run the [yosys Verilog analysis tool](http://www.clifford.at/yosys/) on your code, looking for common issues. These issues will be printed to the screen, and also logged to the file `check.log` that you can view later with a text editor or a text file viewer like `less`.

Some warnings you will encounter in Lab 1 (and beyond):
* _multiple conflicting drivers_: two input wires are wired together, resulting in an undefined value
* _Wire XYZ is used but has no driver_: some wire is not connected to any module's output, so it has an undefined value
* _found logic loop in module_: a "short circuit" exists in the design where a module's output connects to its input without any sequential element in between, creating undefined values. Note that these loops are often detected at the module _declaration_, when the problem actually lies with one of the module's _instantiations_. Still, knowing the module involved is a useful clue for debugging.
* _Resizing cell port ..._: the size of some wire vector does not match the width of the input/output port it's connected to

As you resolve these warnings, re-run `make check` to see what code analysis finds. Sometimes one bug can mask another!

## Run synthesis

> Note also that when you first run `make synth` you'll encounter an error that Vivado can't be found, and to run the command `source /home1/c/cis371/software/Vivado/2017.4/settings64.sh` to fix it (yes, the use of the `cis371` course directory is intentional, it's where Vivado is installed). This command sets up your path so that the Vivado tools are accessible. To avoid having to run this command every time you login to biglab, you can add it to your `~/.bash_profile` file and it will automatically get run every time you login.

Now, still from the `lab1` directory, run the command `make synth`. This will launch synthesis, and it will
take about 2 minutes to complete. If something is really wrong with a design, it
will not synthesize. But even designs with many serious problems (such as the
initial code in this lab) will synthesize successfully. Completing synthesis
doesn't mean much!

### Check Vivado log

After synthesis finishes running, you should examine the log files to check
for warnings. First, examine the file `vivado.log` which records everything that
was printed to the screen while synthesis ran. Here are some tips on how to interpret the messages you see:

+ A "net without a driver" is a wire that does not have anything
connected to it, which is usually indicative of a bug.
+ A "multi-driven net" is a
wire that has too many inputs - each wire should be connected to just a single
source. This is definitely a bug.
+ A "disconnected port" is an input or output
port of a module that isn't connected to anything - also likely a bug.

These warnings are hints to help you fix the bugs in this lab, and will also be
valuable hints about the bugs you encounter in future labs. As you fix bugs, you
can re-run synthesis via `make synth` to see if the warning goes away, or is
perhaps replaced by another one - sometimes one bug can mask another!

One important thing to note - you should never have any **CRITICAL WARNINGS** in your design. If Vivado identifies a hard **ERROR** it will stop synthesis/implementation, but critical warnings are often permitted through. But it is in your best interest to fix them.

> You may have noticed that `make check` is _much_ faster to run than `make synth`. I don't have enough experience running the `yosys` tool (that underpins `make check`) to know whether it detects all of the issues that Vivado's synthesis can detect. So we recommend running both, since it's always nice to let the computers find bugs for us. If your design exhibits an issue that is detected by `make synth` but not by `make check` (or vice-versa), we'd love to hear about it!

#### Benign Warnings

Some of the Vivado warnings are benign or unavoidable. Unfortunately we don't know a good way to suppress these warnings without also suppressing other useful ones. We catalog some of these benign warnings below:

```
WARNING: [Synth 8-3917] design rca4 has port LED[7] driven by constant 0
```
Only 4 of the Zedboard's 8 LEDs are used in this lab, so the high-order four
LEDs (7-4) are hard-wired to zero which is fine. 

```
WARNING: [Vivado 12-3502] Design has no clocks defined.
```
This is ok because the Lab 1 design is purely combinational, so we don't expect it to have any clocks.

```
WARNING: [DRC ZPS7-1] PS7 block required
```
Vivado reminds us that we aren't using the ARM cores embedded on the FPGA, which is fine because we don't need them for anything.

### Examine Design Rule Checks Report

After you've fixed all the important warnings from `vivado.log`, you should
examine the Design Rule Check (DRC) report in
`output/post_synth_drc_report.txt`. DRCs are additional sanity checks that
Vivado runs to make sure that the design is reasonable. Sometimes they overlap
with the warnings in `vivado.log`, but often they are separate and no less
serious.

Two DRC warnings that you *can* ignore are the following:
```
ZPS7-1#1 Warning
PS7 block required
```
See the PS7 discussion under _Benign Warnings_ above.

```
**NSTD-1#1 Critical Warning
Unspecified I/O Standard
```
```
UCIO-1#1 Critical Warning
Unconstrained Logical Port
```
These critical warnings can appear when you run `make synth` but should disappear when you run `make impl`. They arise because, during synthesis, Vivado seems to ignore information about the physical ZedBoard specifications, and then it gives this warning complaining that it doesn't have information about the electrical characteristics of the various I/O pins in the design. In `make impl`, Vivado does take the physical specs into account which avoids these warnings.

There are other interesting reports in the `output/` directory. We'll dig into
these more in future labs, but here's a quick summary:

+ `post_synth_utilization.txt` shows how much of the FPGA's resources (LUTs, registers, block RAMs, etc.) were used by the design.
+ `post_synth_timing_summary_report.txt` discusses whether the design met its timing constraints or not. The modules in this lab do not have any timing constraints to satisfy, so this report is pretty vacuous for now.

## Revisiting the Tests

Even after you resolve all the warnings, it is likely that some of the tests
will still fail. If we're supposed to add two numbers but we subtract instead, Vivado
will never be able to figure this out: we can have a perfectly well-formed
circuit that just doesn't do what it's supposed to do.

To help hone in on these failing tests, you should pick just one failing test
case (a single input to a particular module) and examine it. It may be helpful
to write your own, smaller testbench (or comment out parts of `rca_testbench.v`)
so that you can run just the input of interest. Start by debugging the lowest-level
module, since those bugs may be the root cause of failures in other, higher-level modules that use the lowest-level modules.

There is some code at the top of the `rca_testbench.v` testbench file for adjusting the testbench behavior:
```
`define MAX_ERRORS_TO_DISPLAY ...
```
You can edit this to change how many errors are printed out. Often, the first error is the most important one since errors tend to "compound". For example, this lab's testbench tests the lowest-level modules first. An error in a lower-level module _M_ will almost certainly contribute to errors in higher-level modules that use _M_. In later labs, an error can corrupt a state element like a register, causing many subsequent errors. So pay special attention to the first error :-).

## Submitting Code

Once your code passes all the tests, you are ready to submit it **via Gradescope**. Run the `make zip` command to generate an archive file `rca.zip` with the appropriate contents (your Verilog code and the bitstream), and then upload this file to Gradescope. Be sure to run `make impl` prior to `make zip`, so that the bitstream is included with your submission.

## Zedboard Demo

The next step is **running the demo** of your working design on the Zedboards allocated to your group. The toggle switches at the bottom of the Zedboard are used to input two 4-bit integers, and their 4-bit sum is displayed on the lowest-order 4 LEDs. 

### Generating a bitstream

Run the command `make impl` to generate a `.bit` bitstream file. This will run
the *implementation* step of the FPGA design flow, mapping your design onto the
ZedBoard's hardware. It will take a few minutes. 

When implementation completes, it should create a bitstream file `output/rca4.bit`.

### Programming via Linux command line (recommended)

The simplest way to program the ZedBoards is to use a SEAS Linux machine, found in Moore 100A, the K
Lab in Moore 200, and a few in Towne M70.

> Note that stations in the K Lab have both a Windows *and* a Linux machine (the Linux machines in the K Lab are the machines **with all-black USB ports on the front**. The machines with the blue USB 3.0 ports are the Windows machines.). You can switch between them via the KVM (keyboard/video/mouse) switch beneath the monitor: the Linux machine is typically **input 2**.

Once you login to the machine, follow the [instructions for connecting the
ZedBoard](https://docs.google.com/presentation/d/1spwy8Ech3oLO72_VbKN5WkDlwbWy0WWISxv_lMjhRkg/edit?usp=sharing),
and then switch to the terminal application. From the
lab1 directory, run the command `make program`. You will be prompted for the
`.bit` bitstream file you want to use, and then the FPGA should get programmed
accordingly.

#### Programming via Vivado GUI

You can also program the ZedBoard via the Vivado GUI. See [instructions for Windows here](https://docs.google.com/presentation/d/1spwy8Ech3oLO72_VbKN5WkDlwbWy0WWISxv_lMjhRkg/edit?usp=sharing). 

You can use similar instructions to program via the Vivado GUI on a Linux machine. Start Vivado by running the usual `source ...` command to get the Vivado tools onto your PATH, then run the command `vivado &` on the command line and the GUI should appear within a few moments. You can then follow the Windows tutorial linked above as the menus are identical.

In our experience, the Linux version is substantially more responsive than the Windows version (not the fault of Windows, it seems to be due to the way that the Windows version of Vivado is installed onto a network drive).
